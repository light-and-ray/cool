# Произвольное число аргументов любых типов на C11 и выше с помощью _Generic и variadic макросов

## О себе

Я сам программист на C++, вернее я только начинающий, без коммерческого опыта. Изначально я познакомился с языком Си, а C++ открыл как мощное расширение языка C. В нем на мой взгляд  добавлены те необходимые полезные вещи, которых нет в C (перегрузка функций, классы, пространства имен и др), при этом эти вещи отлично расширяют философию языка

## Задумка

Я узнал что в C стандарта 2011 года добавили небольшую возможность "перегрузки" функций с помощью макроса. (Generic selection) Мне, очень интересно стало написать какую-нибудь функцию, которая максимально использовала бы эту возможность

Задумка: написать (макро) функцию print, которая выводит через пробел все переданные в нее аргументы. Звучит невероятно для Си, где обычно указывают тип принимаемого аргумента одной буквой в имени, и явно указывают число переданных аргументов. Но с джейнериками из C11 это возможно

Простой пример с одним аргументом

Ввиду в суть работы этой перегрузки по типу на простом примере с одним аргументом

Напишем три функции print(x) для типов int, float и char* (cstring):

С помощью данного макроса соединим из под одним именем print:

В итоге получим, что запись print("hi") вызывает print_string("hi"), print(5.5) вызывает print_float(5.5) и так далее

После обработки препроцессором запись print("hi")  превратится в _Generic(("hi"), int: print_int, float: print_float, char*: print_string)("hi"), и компилятор в зависимости от типа первого аргумента выберет имя функции, которую надо подставить вместо всего выражения _Generic(...)

Неопределенное число однородных аргументов

С помощью макросов также можно передавать неопределенное число аргументов без явного указания их числа. Покажу на примере для функции print_int

С помощью макроса, который я любезно скопипастил из гугла :) можем вывести число аргументов n, и передать его в функцию первым аргументом

Примечание: __VA_ARGS__ содержит в себе аргументы, которые попали в ...

Соответственно для джейнериков, если все аргументы одного типа, мы должны написать

В итоге получим функцию function, которая обрабатывает неопределенное число однотипных аргументов. Я написал function, а не print, так как для нашей функции это точно не подойдет. Однако если вам известно, что все аргументы одного и того же типа, то такой способ будет намного проще, чем когда любой аргумент любого типа

## Неопределенное число аргументов любого типа

### I. Хранение информации о типах

Мы создадим универсальную функцию вида (синтаксис вольный) hidden_print(sep, n, x1, x2, x3, ...), которая в зависимости от типа следующей  переменной xi выполняет нужный printf. Для любой другой реализации можно вызывать нужную функцию с уже известным типом

Для определенности максимальное число аргументов будет 12. Для print'а этого достаточно. 

Все глобальные имена будут начинаться с приставки cool_. Это что-то вроде пространства имен, просто я решил создать отдельную несерьезную, удобно подключаемую библиотечку, в которой хранятся такие интересные, но практически не очень полезные штучки. В этой библиотеке на c++ все функции обьявлены в пространстве имен cool, однако в Си пространств имен нет, так что пользуюсь приставками. Однако в любой момент можно сделать #define print cool_print, а затем #undef print

Для хранения информации о типах аргументов буду использовать массив cool_hidden_types[12], индекс cool_hidden_last, куда надо добавить следущий элемент cool_hidden_add_int, cool_hidden_add_float и т.д. для каждого типа, которые добавляют в массив значение о типах. Всего наша функция будет поддерживать 7 типов: int, char*, float, double, char (?), uint, long

Почему-то при записи _Generic(('a'), char: fun_char)() компилятор выдает что-то вроде "не найдена функция для int", так что на практике если передать символ в одинарных кавычках ничего не получится и он дай бог выведется как int

Значения о типах я решил определить с помощью #define, хотя в си есть и enum. Но раз уж тут почти весь код на макросах, то гулять так гулять!

COOL_HIDDEN_VOID будет означать, что данный тип не поддерживается функцией. Можно было бы заморочиться и передавать информацию о размере переменной и выводить в 16-ричном виде для любой другой переменной, но я не стал это делать

Создадим теперь generic макро функцию cool_hidden_add(x), которая будет добавлять элемент в массив в зависимости от типа x

Это было самое простое...

### II. Определение числа аргументов на уровне макроса

Идея заключается в том, чтобы определить макрос вида cool_print_##n(x1, x2, ..., xn) ("##" означает конкатенацию со значением n), который по очереди добавляет информацию о типе каждого xi, а затем передает в функцию реализации cool_hidden_print(sep, n, x1, x2, ...) разделитель, n, и все xi. Разделитель я определю как глобальную (если так вообще можно называть переменные с уникальной приставкой) переменную cool_print_sep = " ", которую можно изменить в любой момент

Определим это простым образом через копирование. Хотя наверное их можно было бы сгенерировать макросами, но мне было уже лень. (К тому же у меня и так статический анализатор  visual studio заблудился в куче макросов и указывает ошибку там, где все нормально компилируется, но об этом позже)

Немного проспойлерил, что аргументов макро функции cool_print_n всегда 12, и что после нее идет ..., но об этом далее

Значение выполнения макроса PP_NARG(_VA_ARGS_) не возможно подставить напрямую в выражение cool_print_##PP_NARG(_VA_ARGS_), так как оно развернется в что-то вроде cool_print_PP_NARG("x", 5, "i", 8,), что не имеет никакого смысла. Поэтому надо использовать код из макроса, но не возвращать число аргументов, а сразу конкатенировать

Как это работает:

### III. Собственно реализация функции

Отлично, у нас при вызове cool_print("наши", "аргументы", 10) происходит заполнение массива cool_hidden_types информацией о типе каждого аргумента, а затем вызывается функция реализации cool_hidden_print(int sep, int n, ...)! Давайте напишем эту функцию

В стандартной библиотеке в заголовочном файле <stdarg.h> есть три макроса, созданных для этих целей. Вот порядок действий:

В обьявлении функции последним параметром надо указать ...

va_list argptr- это определение указателя argptr, который будет в использоваться в дальнейшем

va_start(argptr, n)- установка указателя на последний определенный аргумент

va_arg(argptr, float)- возвращает значение слудующего аргумента

va_end(argptr)- завершает работу с аргументами

Итого просто в Си без всяких этих макросов нам необходимо вычислять какими-нибудь образом тип следующего аргумента, и условии прекращения перебора аргументов

Суть такова: в цикле перебираются все элементы все элементы. В swich'e каждый элемент кастится в void'ый указатель x, а затем вызывается в виде printf("...%s", *((type) x), sep), где type - это тип аргумента, а "..." - это специфичный для данного типа формат вывода. Например для int это printf("%d%s", *((type) x), sep). Для упрощенной записи приведения типов я использую вспомогательный макрос #define COOL_CAST(T, x) *((T*) (x))

### Дополнительные мелочи

После подключения библиотеки можно избавиться от приставки cool_ с помощью

#define print cool_print

Идеально, теперь наша функция print полностью работает! В качестве вишенки на торте определим функцию println, которая после вывода переводит нас на новую строку

К моему большому сожалению я не смог решить проблему, что при вызове макроса без аргументов происходит синтаксическая ошибка из-за лишней запятой в начале, поэтому без аргументов нужно вызывать printlnn()... Я пытался решить это, при определении cool_print

Как советуют в интернете делать при таком случае ничего не происходит. Видимо эта запись работает только для ,## __VA_ARGS__, когда __VA_ARGS__ идет в конце, а не в начале

Возможно можно как-нибудь еще одним вложенным макросом определить, является ли __VA_ARGS__ пустым. Я нашел в гугле решение только тогда когда максимум 2 аргумента

Еще есть еще некий __VAR_OPT__, который делает как раз то, что нужно, но его добавят, как я понял, в следующем стандарте

У меня почему-то сработало один раз (,), но после перезапуска visual stidio стало __VAR_OPT__ не определено. К тому же в том месте __VAR_OPT__ ставить нельза, так как макрос будет считать что у нас 63 а не 64 аргумента (что приводила к ошибке вызова не того cool_print##n (на единицу меньше). Нужно что-то вроде

## Проблемы этого метода

Первое - это конечно же невозможность вызвать функцию без аргументов. К тому же огромным минусом является то, что в случае ошибки генерируется очень невнятное сообщение об ошибке, и я не вижу куда можно вставить его

Второе - сложность реализации. На C++ аналогичная функция выглядит намного проще. Хотя, имея в качестве шаблона мою функцию print будет не так сложно реализовать любую другую

Третье - статический анализатор. В visual studio у меня подчеркнут красным каждый print и println со словами "требуется выражение", и висит по одной ошибки (прям красным цветом) на каждый вызов этой функции. Не смотря на это все нормально компилируется. И даже не думаю что на это должно тратиться сильно больше времени, чем на раскрытие variadic templates в c++, хотя я тесты не проводил (а как вообще замерить время компиляции - это отдельный вопрос)

Этот минус самый пожалуй критичный. Если знаете как можно подавить эти ложные ошибки, то подскажите в комментариях

Полный код данной библиотечки можете найти по ссылке на моем гитхабе: print.h

А вот пример использования c_example.c

## Заключение

Удивительно сколько всего можно сделать на чистом Си с очень слабыми шаблонами. Но все же Си предназначен не совсем для этого. Данная статья нужна в большей мере для интереса, хотя может кому-нибудь и поможет в работе. Для удобств написания кода на Си как раз и был создан C++, который позволяет работать с обьектами через класс, а не писать id обьекта первым параметром в методах; он позваляет делать перегрузку функций для тех случаев, когда это необходимо (чтобы не городить функции типа pow, powi, powf); упрощает работу с указателями, добавляя ссылки, добавляет пространства имен, чтобы не городить приставок. Но как итог всего этого - медленная компиляция

Вот пример реализации этой же функции print на C++:

Более понятно, примерно в 3 раза меньше кода, и реализация более полноценная. Но в то же время стандартный printf хоть и выглядит не так изящно, но зато быстрый и практичный. Каждому языку свое место